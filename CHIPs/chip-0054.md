CHIP Number   | XXXX
:-------------|:----
Title         | Layer 2 Consensus Anchoring Protocol
Description   | A standard for building decentralized Layer 2 consensus networks that inherit security from Chia
Author        | [Michael Taylor (DIG Network)](https://github.com/DIG-Network)
Editor        | TBD
Comments-URI  | TBD
Status        | Draft
Category      | Standards Track
Sub-Category  | Network
Created       | 2025-12-30
Requires      | None
Replaces      | None
Superseded-By | None

## Abstract

This CHIP specifies a protocol for building decentralized Layer 2 consensus networks anchored to Chia.

The core innovation is **coordination-free consensus** secured by the Chia Blockchain: every peer operates independently, yet all honest peers arrive at the same L2 canonical chain. There is no leader election, no peer-to-peer voting rounds, and no communication required beyond publishing coins to L1. Each peer simply reads L1, applies deterministic rules, and reaches the same conclusion as every other peer.

This works because:
1. **Deterministic selection**: Given the same L1 state, all peers compute the same block ranking
2. **On-chain evidence**: Proposals and attestations are L1 coins—visible to everyone, forgeable by no one
3. **Self-proving eligibility**: Collateral coins prove participation rights without a registry

Any participant can independently verify the canonical chain by querying L1. No trusted parties, no synchronous communication, no coordination overhead.

## Motivation

Chia is a general-purpose blockchain with strong security. It excels as a financial layer—proof-of-space-and-time provides robust finality, and programmable puzzles enable sophisticated financial primitives.

But applications built on Chia often need consensus on **application-specific state** beyond simple transactions. Consider a decentralized storage network:

- Nodes constantly submit storage proofs
- Verifiers submit verification attestations  
- The network must agree on routing information, relay nodes, and content linking
- All participants need access to current network state

Writing every proof, verification, and routing update directly to Chia would be extremely expensive, wasteful of L1 blockspace, and slower than necessary. The cost savings from batching are astronomical.

This CHIP enables applications to maintain **specialized blockchains** with their own consensus while inheriting Chia's security for finalization:

1. Application-specific L2 blocks store all domain data
2. Decentralized peers reach consensus through proposals and attestations
3. Only finalization data touches L1—minimal footprint proving consensus was achieved
4. L1 anchoring makes finalization effectively immutable

The L2 can be data-rich and highly specialized. Meanwhile, Chia remains the financial and security layer—managing tokens, handling payments, providing ultimate finality. Finalizing L2 blocks on Chia inherits its Nakamoto coefficient and proof-of-space-and-time security without building an entire general-purpose chain.

## Backwards Compatibility

No changes to Chia's consensus rules, transaction format, or network protocol. Proposals are standard coins with memos. Attestations use P2 parent to prove their parent was a specific proposal. Collateral uses custom puzzles enforcing the two-phase withdrawal flow.

## Specification

### Overview

L2 consensus operates in **epochs**—fixed-length periods measured in L1 blocks. Each epoch produces one canonical L2 block through two phases:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         EPOCH LIFECYCLE                             │
├─────────────────────────────────────────────────────────────────────┤
│  L1 Height:  [epoch_start]────────[midpoint]────────[epoch_end]     │
│              ┌─────────────────┬─────────────────┐                  │
│              │ PROPOSAL WINDOW │ ELECTION WINDOW │                  │
│              └─────────────────┴─────────────────┘                  │
│                                                                     │
│  PROPOSAL (epoch_start to midpoint):                                │
│    • Peers construct candidate blocks                               │
│    • Peers publish proposal coins on L1                             │
│    • Peers broadcast full blocks via gossip                         │
│                                                                     │
│  ELECTION (midpoint to epoch_end):                                  │
│    • Deterministic selection ranks proposals                        │
│    • Peers verify winning block and lineage                         │
│    • Peers publish attestation coins                                │
│    • Block with most attestations becomes canonical                 │
└─────────────────────────────────────────────────────────────────────┘
```

### Why This Works Without Coordination

This protocol requires no direct communication between peers to reach consensus. Each peer operates independently, yet all honest peers arrive at the same canonical chain. Here's how:

**Shared clock via L1**: All peers observe the same Chia blockchain. L1 block heights serve as a global clock—when peers see the same L1 height, they know they're in the same epoch phase. No clock synchronization needed.

**Deterministic selection from shared state**: The winning block is determined by XOR distance between proposal hashes and a selection target derived from the L1 block hash at `epoch_start`. Every peer reading the same L1 state computes the same ranking.

**Self-proving eligibility via coins**: To propose or attest, a peer must have collateral locked on L1. The L1  coin itself proves eligibility—anyone can verify it by querying L1 with the peer's pubkey. No registry, no permission.

**Attestations as independent votes**: Each peer independently determines which block wins (using deterministic selection), then publishes an attestation coin. Peers don't need to see each other's attestations before voting—they're all computing the same answer from the same inputs.

The result: peers that have never communicated, running on opposite sides of the world, will independently arrive at the same canonical chain—simply by reading L1 and applying the same deterministic rules.

**Time measurement**: All timing in this protocol is measured in L1 blocks, not wall-clock time. One L1 block equals one unit of time for the L2 network, regardless of actual time between L1 blocks.

**Gossip protocol**: This CHIP assumes full block data propagates between peers via gossip but intentionally does not specify the gossip protocol. Peer discovery, block request/response formats, and network topology are implementation-specific and depend on the network's needs.

### Network Configuration

```
NetworkConfig {
    consensus_version: u32,                  // Protocol version for compatibility
    network_id: [u8; 32],                    // Unique identifier
    genesis_l1_height: u64,                  // L1 height when L2 network begins
    proposal_puzzle_hash: [u8; 32],
    attestation_puzzle_hash: [u8; 32],
    collateral_puzzle_hash: [u8; 32],
    pending_puzzle_hash: [u8; 32],           // Pending collateral puzzle hash
    min_collateral: u64,                     // Mojos required
    max_block_size: u64,                     // Maximum L2 block size in bytes
    epoch_length_blocks: u64,                // L1 blocks per epoch
    min_attestations: u32,                   // Required for finality
    equivocation_cooloff_epochs: u64,        // Ban duration
    decollateralization_delay_epochs: u64,   // MUST be >= cooloff
    max_reorg_depth: u64,
}
```

The `consensus_version` identifies which version of this protocol the network follows. Peers MUST reject blocks from networks with incompatible consensus versions. This enables protocol upgrades while maintaining clear compatibility boundaries.

The `genesis_l1_height` specifies when the L2 network begins. This is typically set to a future L1 block height on first network startup. Once that L1 block exists, epoch 0 begins and the L2 network is live.

### P2 Parent Puzzle

Attestations and pending collateral use the P2 parent puzzle to verify their parent coin:

```chialisp
(mod
  (
    MORPHER              ; For no morphing, use 1
    parent_parent_id
    parent_inner_puz
    parent_amount
    parent_solution
  )
  (include condition_codes.clib)
  (include curry-and-treehash.clib)
  (c
    (list ASSERT_MY_PARENT_ID
      (calculate_coin_id parent_parent_id (a MORPHER (sha256tree parent_inner_puz)) parent_amount)
    )
    (a parent_inner_puz parent_solution)
  )
)
```

**Attestations** use P2 parent to prove their parent coin was a specific proposal coin—this cryptographically binds the attestation to the block it endorses.

**Pending collateral** uses P2 parent to prove its parent was a valid collateral coin—this prevents forging pending coins to bypass the time-lock.

Proposals are standard coins with memos. Collateral uses custom puzzles (see Time-Locked Withdrawal).

### Domain Separators

| Constant | Value |
|----------|-------|
| `EPOCH_ID_DOMAIN` | `b"CHIA-L2-EPOCH-ID-v1"` |
| `BLOCK_HASH_DOMAIN` | `b"CHIA-L2-BLOCK-HASH-v1"` |
| `PROPOSAL_DOMAIN` | `b"CHIA-L2-PROPOSAL-HINT-v1"` |
| `PROPOSAL_SIGN_DOMAIN` | `b"CHIA-L2-PROPOSAL-v1"` |
| `ATTESTATION_DOMAIN` | `b"CHIA-L2-ATTESTATION-HINT-v1"` |
| `ATTESTATION_SIGN_DOMAIN` | `b"CHIA-L2-ATTESTATION-v1"` |
| `SELECTION_DOMAIN` | `b"CHIA-L2-SELECTION-v1"` |
| `COLLATERAL_DOMAIN` | `b"CHIA-L2-COLLATERAL-v1"` |
| `PENDING_DOMAIN` | `b"CHIA-L2-PENDING-v1"` |
| `DECOLLATERALIZE_DOMAIN` | `b"CHIA-L2-DECOLLATERALIZE-v1"` |
| `CLAIM_DOMAIN` | `b"CHIA-L2-CLAIM-v1"` |
| `DATA_HASH_DOMAIN` | `b"CHIA-L2-DATA-HASH-v1"` |

### Epoch Timing

```
COMPUTE_EPOCH_BOUNDARIES(genesis_l1_height, epoch_number, epoch_length):
    epoch_start = genesis_l1_height + (epoch_number * epoch_length)
    midpoint    = epoch_start + (epoch_length / 2)
    epoch_end   = epoch_start + epoch_length

COMPUTE_EPOCH_ID(network_id, epoch_number) -> [u8; 32]:
    return SHA256(EPOCH_ID_DOMAIN || network_id || epoch_number.to_le_bytes())
```

### L2 Block Structure

**Block Header**

| Field | Type | Size |
|-------|------|------|
| `version` | u32 | 4 |
| `network_id` | [u8; 32] | 32 |
| `epoch` | u64 | 8 |
| `prev_block_hash` | [u8; 32] | 32 |
| `data_root` | [u8; 32] | 32 |
| `data_count` | u32 | 4 |
| `proposer_pubkey` | [u8; 48] | 48 |

The block `version` MUST match the network's `consensus_version`. Honest peers MUST reject blocks with mismatched versions.

```
COMPUTE_BLOCK_HASH(header) -> [u8; 32]:
    return SHA256(BLOCK_HASH_DOMAIN || header.to_bytes())
```

**Block Body**

```
L2Block {
    header: L2BlockHeader,
    
    // Application-specific data items.
    // MUST be sorted by hash for deterministic Merkle root.
    data: Vec<DataItem>,
}
```

The `DataItem` type is application-specific—this CHIP does not define its contents. Networks define their own data item format based on their needs (storage proofs, attestations, transactions, etc.).

**Data Root Computation**

```
COMPUTE_DATA_ROOT(data) -> [u8; 32]:
    // 1. Hash each data item
    leaves = []
    for item in data:
        leaf = SHA256(DATA_HASH_DOMAIN || item.to_bytes())
        leaves.append(leaf)
    
    // 2. Sort leaves lexicographically for determinism
    leaves.sort()
    
    // 3. Handle empty case
    if leaves.is_empty():
        return [0u8; 32]
    
    // 4. Build binary Merkle tree
    while leaves.len() > 1:
        next_level = []
        for i in range(0, leaves.len(), 2):
            if i + 1 < leaves.len():
                parent = SHA256(leaves[i] || leaves[i + 1])
            else:
                parent = leaves[i]  // Odd leaf promoted
            next_level.append(parent)
        leaves = next_level
    
    return leaves[0]
```

The `data_count` in the header MUST equal `data.len()`.

### Proposals

Proposal coins are standard 1 mojo coins with hint = `SHA256(PROPOSAL_DOMAIN || epoch_id)` for queryability.

| Memo | Content | Size |
|------|---------|------|
| 0 | `epoch_id` | 32 |
| 1 | `block_hash` | 32 |
| 2 | `proposer_pubkey` | 48 |
| 3 | `proposal_signature` | 96 |
| 4 | `l1_block_hash` | 32 |

The `l1_block_hash` (freshness proof) must reference the L1 block at exactly `epoch_start`—this prevents pre-computing blocks before the epoch begins and ensures all proposals reference the same anchor.

The `proposer_pubkey` and `proposal_signature` in the memo prove the coin creator controls the pubkey. Validators check if this pubkey has sufficient collateral—this indirectly proves eligibility without requiring a peer registry.

```
SIGN_PROPOSAL(epoch_id, block_hash, l1_block_hash, secret_key) -> [u8; 96]:
    pubkey = derive_pubkey(secret_key)
    signable = PROPOSAL_SIGN_DOMAIN || epoch_id || block_hash || l1_block_hash || pubkey
    return BLS_Sign(secret_key, signable)
```

Proposals must confirm within `[epoch_start, midpoint)`.

### Block Selection

Selection uses the L1 block hash at `epoch_start` as a random seed. Using L1 (not the previous L2 block) prevents reorganization cascades—an L2 reorg won't change selection for subsequent epochs.

```
GET_SELECTION_SEED(genesis_l1_height, epoch_number, epoch_length) -> [u8; 32]:
    epoch_start = genesis_l1_height + (epoch_number * epoch_length)
    return chia_client.get_block_at_height(epoch_start).header_hash

SELECT_WINNING_BLOCK(proposals, genesis_l1_height, epoch_number, epoch_length) -> Vec<Proposal>:
    seed = GET_SELECTION_SEED(genesis_l1_height, epoch_number, epoch_length)
    target = SHA256(SELECTION_DOMAIN || seed)
    
    scored = proposals.map(|p| (XOR(target, p.block_hash), p))
    scored.sort_by_key(|(distance, _)| distance)
    return scored.map(|(_, p)| p)
```

Selection operates on `block_hash`, not proposer identity—proposers commit to specific contents before knowing if they'll win.

### Attestations

Attestation coins are 1 mojo coins using P2 parent to prove their parent was the proposal coin they endorse. Hint = `SHA256(ATTESTATION_DOMAIN || block_hash)` for queryability.

| Memo | Content | Size |
|------|---------|------|
| 0 | `block_hash` | 32 |
| 1 | `attester_pubkey` | 48 |
| 2 | `attestation_signature` | 96 |

The `attester_pubkey` and `attestation_signature` prove the coin creator controls the pubkey. Validators check if this pubkey has sufficient collateral to count the attestation.

```
SIGN_ATTESTATION(block_hash, secret_key) -> [u8; 96]:
    pubkey = derive_pubkey(secret_key)
    signable = ATTESTATION_SIGN_DOMAIN || block_hash || pubkey
    return BLS_Sign(secret_key, signable)
```

Attestations must confirm within `[midpoint, epoch_end)`.

**Attestation weighting**: Earlier attestations carry more weight. Attestations are weighted by how many L1 blocks remain in the attestation window when they confirm:

```
ATTESTATION_WEIGHT(attestation_height, midpoint, epoch_end):
    remaining = epoch_end - attestation_height
    window_size = epoch_end - midpoint
    return remaining / window_size
```

An attestation at `midpoint` has weight 1.0; at `epoch_end - 1` has weight near 0. This incentivizes attesters to verify and submit quickly rather than waiting to see which block is accumulating votes.

### Canonical Block Determination

Honest attesters independently compute the selection winner and attest to it—they don't need to observe other attestations. The canonical block is determined by weighted attestation score:

```
DETERMINE_CANONICAL_BLOCK(network_id, genesis_l1_height, epoch_number, epoch_length):
    proposals = QUERY_VALID_PROPOSALS(network_id, epoch_number, epoch_length)
    ordered = SELECT_WINNING_BLOCK(proposals, genesis_l1_height, epoch_number, epoch_length)
    bounds = COMPUTE_EPOCH_BOUNDARIES(genesis_l1_height, epoch_number, epoch_length)
    
    best_block, best_score, best_count = None, 0, 0
    for proposal in ordered:
        attestations = QUERY_VALID_ATTESTATIONS(proposal.block_hash, epoch_number)
        score = sum(ATTESTATION_WEIGHT(a.height, bounds.midpoint, bounds.epoch_end) 
                    for a in attestations)
        if score > best_score:
            best_block, best_score, best_count = proposal, score, len(attestations)
    
    if best_count < min_attestations:
        return NULL_BLOCK(network_id, genesis_l1_height, epoch_number, epoch_length)
    return best_block
```

### Null Blocks

When an epoch fails to reach `min_attestations`, peers insert a null block to maintain chain continuity:

```
NULL_BLOCK(network_id, genesis_l1_height, epoch_number, epoch_length) -> L2BlockHeader:
    if epoch_number == 0:
        prev_hash = [0u8; 32]
    else:
        prev_block = DETERMINE_CANONICAL_BLOCK(network_id, genesis_l1_height, epoch_number - 1, epoch_length)
        prev_hash = COMPUTE_BLOCK_HASH(prev_block.header)
    
    return L2BlockHeader {
        version: 1,
        network_id: network_id,
        epoch: epoch_number,
        prev_block_hash: prev_hash,
        data_root: [0u8; 32],
        data_count: 0,
        proposer_pubkey: [0u8; 48],
    }

NULL_BLOCK_HASH(network_id, genesis_l1_height, epoch_number, epoch_length) -> [u8; 32]:
    return COMPUTE_BLOCK_HASH(NULL_BLOCK(network_id, genesis_l1_height, epoch_number, epoch_length))
```

Null blocks are deterministic—all peers compute the same null block for a failed epoch. The `prev_block_hash` references the previous epoch's canonical block (which may itself be a null block). This ensures the chain remains continuous with no gaps in the epoch sequence.

### Chain Reorganization

Each block's `prev_block_hash` links to the previous epoch. On lineage mismatch, walk backward re-selecting canonical blocks until chains align:

```
VERIFY_BLOCK_LINEAGE(block, local_chain):
    if block.header.epoch == 0:
        return block.header.prev_block_hash == [0u8; 32]
    
    local_prev = local_chain.get_block(block.header.epoch - 1)
    return block.header.prev_block_hash == COMPUTE_BLOCK_HASH(local_prev.header)

HANDLE_REORG(network_id, genesis_l1_height, epoch_length, current_epoch, winning_block, local_chain):
    reorg_blocks = []
    check_block = winning_block
    
    while check_block.header.epoch > 0:
        if VERIFY_BLOCK_LINEAGE(check_block, local_chain):
            return reorg_blocks.reverse()
        
        reorg_blocks.push(check_block)
        prev_canonical = DETERMINE_CANONICAL_BLOCK(
            network_id, genesis_l1_height, check_block.header.epoch - 1, epoch_length)
        check_block = fetch_block(prev_canonical.block_hash)
    
    return reorg_blocks.reverse()
```

Implementations SHOULD enforce `max_reorg_depth`.

### Equivocation

Submitting multiple proposals or attestations in one epoch from the same pubkey is **equivocation**. Detectable from on-chain data alone—query, group by pubkey, flag duplicates. Equivocators enter cooloff:

```
IS_IN_COOLOFF(pubkey, current_epoch):
    record = get_latest_equivocation(pubkey)
    return current_epoch < record.offense_epoch + equivocation_cooloff_epochs
```

The protocol does not distinguish between intentional and accidental equivocation—both result in cooloff. Implementations MUST include safeguards to prevent accidental double-submission, such as checking for existing proposals/attestations before broadcasting.

### Collateral

Peers lock collateral for Sybil resistance. Verified at `epoch_start` for consistent eligibility:

```
HAS_SUFFICIENT_COLLATERAL(peer_pubkey, snapshot_height):
    // Check for any pending coins - if found, peer is ineligible
    pending_hint = SHA256(PENDING_DOMAIN || peer_pubkey)
    pending_coins = chia_client.get_coins_by_hint_at_height(pending_hint, snapshot_height)
        .filter(|c| c.puzzle_hash == pending_puzzle_hash)
        .filter(|c| c.created_height <= snapshot_height)
        .filter(|c| !c.spent || c.spent_height > snapshot_height)
    
    if !pending_coins.is_empty(): return false
    
    // Check for active collateral
    collateral_hint = SHA256(COLLATERAL_DOMAIN || peer_pubkey)
    active_coins = chia_client.get_coins_by_hint_at_height(collateral_hint, snapshot_height)
        .filter(|c| c.puzzle_hash == collateral_puzzle_hash)
        .filter(|c| c.created_height <= snapshot_height)
        .filter(|c| !c.spent || c.spent_height > snapshot_height)
    
    if active_coins.is_empty(): return false
    
    // Only the earliest-minted active collateral coin counts
    earliest = active_coins.min_by(|c| c.created_height)
    return earliest.amount >= min_collateral
```

**Collateral rules:**
- A peer can have multiple spent (withdrawn) collateral coins, but only ONE active collateral coin
- If multiple active collateral coins are detected for the same pubkey, only the coin minted at the lowest L1 block height is counted
- If collateral drops below `min_collateral`, the peer is immediately ineligible from participation
- If ANY collateral coin for the peer is in pending state, the peer is ineligible—even if they create new active collateral. Eligibility resumes only after the pending coin is spent (claimed) and active collateral meets `min_collateral`
- Partial withdrawals are not supported—withdrawal moves the entire coin to pending state

Only **active** collateral counts. Once a peer initiates withdrawal, their collateral moves to the pending puzzle hash. Honest nodes see this on-chain and filter that peer out of canonical block selection—they can no longer propose or attest until they re-collateralize.

### Time-Locked Withdrawal

Without time-locks, banned peers could spend collateral and create new identities, bypassing cooloff. Two-phase withdrawal prevents this:

1. **Initiate**: Collateral transitions to "pending" state (peer immediately loses eligibility)
2. **Claim**: After `decollateralization_delay_epochs`, peer can withdraw

The delay MUST be ≥ `equivocation_cooloff_epochs`. By the time a banned peer can access their collateral, cooloff has expired—no advantage from identity recreation.

Collateral uses a custom puzzle that only allows creating pending coins. Pending coins use P2 parent to prove their parent was a valid collateral coin.

```chialisp
; COLLATERAL_PUZZLE - curried with (NETWORK_ID, PUBKEY, PENDING_PUZZLE_HASH, PENDING_HINT, DECOLLATERALIZE_DOMAIN)
; Can only spend by creating a pending withdrawal coin with the correct hint
(mod
  (NETWORK_ID PUBKEY PENDING_PUZZLE_HASH PENDING_HINT DECOLLATERALIZE_DOMAIN)
  (include condition_codes.clib)
  (list
    (list CREATE_COIN PENDING_PUZZLE_HASH @amount (list PENDING_HINT))
    (list AGG_SIG_ME PUBKEY (sha256 DECOLLATERALIZE_DOMAIN NETWORK_ID))
  )
)

; PENDING_INNER_PUZZLE - curried with (NETWORK_ID, PUBKEY, DELAY_BLOCKS, CLAIM_DOMAIN)
; Used inside P2 parent wrapper; enforces time-lock before claim
(mod
  (NETWORK_ID PUBKEY DELAY_BLOCKS CLAIM_DOMAIN destination_puzzle_hash)
  (include condition_codes.clib)
  (list
    (list ASSERT_HEIGHT_RELATIVE DELAY_BLOCKS)
    (list CREATE_COIN destination_puzzle_hash @amount)
    (list AGG_SIG_ME PUBKEY (sha256 CLAIM_DOMAIN NETWORK_ID))
  )
)
```

The `PENDING_HINT` is pre-computed as `SHA256(PENDING_DOMAIN || PUBKEY)` and curried into the collateral puzzle at creation time.

### How the Collateral Puzzles Work

**COLLATERAL_PUZZLE**

```chialisp
(mod (NETWORK_ID PUBKEY PENDING_PUZZLE_HASH PENDING_HINT DECOLLATERALIZE_DOMAIN)
  (include condition_codes.clib)
  (list
    (list CREATE_COIN PENDING_PUZZLE_HASH @amount (list PENDING_HINT))
    (list AGG_SIG_ME PUBKEY (sha256 DECOLLATERALIZE_DOMAIN NETWORK_ID))
  )
)
```

Five **curried parameters** are baked into the puzzle at creation time:
- `NETWORK_ID` - identifies which L2 network this collateral belongs to
- `PUBKEY` - the owner's public key
- `PENDING_PUZZLE_HASH` - the exact puzzle hash of the pending coin that will be created
- `PENDING_HINT` - pre-computed as `SHA256(PENDING_DOMAIN || PUBKEY)` for queryability
- `DECOLLATERALIZE_DOMAIN` - domain separator for the signature message

The puzzle outputs two conditions:
- `CREATE_COIN PENDING_PUZZLE_HASH @amount (list PENDING_HINT)` - creates a pending coin with that specific puzzle hash, passing through the full amount (`@amount` refers to the coin being spent) and attaching the hint for queryability
- `AGG_SIG_ME PUBKEY (sha256 DECOLLATERALIZE_DOMAIN NETWORK_ID)` - requires a signature from the owner

There are no uncurried parameters, so the solution is empty. The puzzle completely determines what happens—it can ONLY create a pending coin with that exact puzzle hash and hint. No other outputs are possible.

**PENDING_INNER_PUZZLE**

```chialisp
(mod (NETWORK_ID PUBKEY DELAY_BLOCKS CLAIM_DOMAIN destination_puzzle_hash)
  (include condition_codes.clib)
  (list
    (list ASSERT_HEIGHT_RELATIVE DELAY_BLOCKS)
    (list CREATE_COIN destination_puzzle_hash @amount)
    (list AGG_SIG_ME PUBKEY (sha256 CLAIM_DOMAIN NETWORK_ID))
  )
)
```

Four curried parameters plus one solution parameter:
- `NETWORK_ID`, `PUBKEY`, `DELAY_BLOCKS`, `CLAIM_DOMAIN` - curried at creation
- `destination_puzzle_hash` - provided at spend time (where to send funds)

The puzzle outputs:
- `ASSERT_HEIGHT_RELATIVE DELAY_BLOCKS` - fails if not enough blocks have passed since this coin was created
- `CREATE_COIN destination_puzzle_hash @amount` - sends funds to owner's chosen destination
- `AGG_SIG_ME PUBKEY (sha256 CLAIM_DOMAIN NETWORK_ID)` - requires owner's signature

This inner puzzle is wrapped with P2 parent, which verifies the pending coin descended from valid collateral. The full pending puzzle hash is computed as:

```
delay_blocks = decollateralization_delay_epochs * epoch_length_blocks
pending_inner = PENDING_INNER_PUZZLE.curry(network_id, pubkey, delay_blocks, CLAIM_DOMAIN)
pending_puzzle_hash = P2_PARENT_PUZZLE.curry(1, pending_inner.tree_hash()).tree_hash()
```

This `pending_puzzle_hash` is then curried into `COLLATERAL_PUZZLE`, locking in the entire withdrawal path at collateral creation time.

### Inclusion Proofs

L2 blocks contain a `data_root`—the Merkle root of all data items in that block. Inclusion proofs let anyone verify that a specific data item exists in a finalized block without downloading the entire block.

**Use cases:**

- **Payment escrow**: A client pays for content by creating an escrow puzzle that releases funds only when the server provides a valid inclusion proof showing their request was served and recorded in a finalized block
- **Dispute resolution**: Prove that a specific attestation, storage proof, or other record was included in the canonical chain at a given epoch
- **Light clients**: Verify specific data without syncing the full L2 chain—just need the block header (which contains `data_root`) and the Merkle proof

```
InclusionProof {
    block_hash: [u8; 32],
    epoch: u64,
    data_index: u32,
    merkle_proof: Vec<[u8; 32]>,
    data_item: DataItem,
}

VERIFY_INCLUSION_PROOF(proof, expected_data_root):
    leaf = SHA256(DATA_HASH_DOMAIN || proof.data_item.to_bytes())
    current = leaf
    for (i, sibling) in proof.merkle_proof.enumerate():
        current = if (proof.data_index >> i) & 1 == 0:
            SHA256(current || sibling)
        else:
            SHA256(sibling || current)
    return current == expected_data_root
```

The verifier checks that the computed root matches the `data_root` in the block header. Since block headers are anchored to L1 via proposals and attestations, inclusion proofs inherit Chia's security guarantees.

## Design Rationale

**L1-anchored selection seed**: Using L1 block hash (not previous L2 block) prevents reorganization cascades. An L2 reorg doesn't change future selections.

**Block hash selection**: Selecting on `block_hash` rather than proposer pubkey prevents block swap attacks—proposers commit to contents before selection.

**Freshness proofs**: Requiring the L1 block hash at exactly `epoch_start` prevents pre-computing blocks and ensures all proposals share the same verifiable L1 anchor.

**Equivocation penalties**: Without them, peers could spam proposals or attest to multiple blocks. On-chain detectability makes penalties trustlessly enforceable.

**Time-locked collateral**: Prevents identity recreation to bypass bans. The withdrawal delay must exceed cooloff duration.

**Weighted attestations**: Earlier attestations count more than later ones. This prevents two problems: (1) free-riding, where attesters wait to see which block is winning before attesting, and (2) attestation buying, where a proposer bribes attesters after seeing they didn't win selection. Honest attesters independently compute the selection winner and attest immediately—they're rewarded for speed, not for following the crowd.

## Test Vectors

### Epoch Boundaries

Verifies correct calculation of epoch start, midpoint, and end from epoch number and length.

```
genesis_l1_height: 1000, epoch_number: 5, epoch_length: 100
→ epoch_start: 1500, midpoint: 1550, epoch_end: 1600
  (epoch_start = genesis_l1_height + epoch_number * epoch_length)
```

### Block Selection

Verifies deterministic winner selection using XOR distance from the selection target derived from the L1 block hash.

```
l1_block_hash_at_500: 0xaaaa...
proposals: [{ block_hash: 0x1111... }, { block_hash: 0x2222... }]

selection_target = SHA256("CHIA-L2-SELECTION-v1" || 0xaaaa...)
winner = proposal with block_hash closest to selection_target (XOR distance)
```

### Timing Validation

Verifies proposals are only valid in the first half of the epoch, attestations only in the second half.

```
genesis_l1_height: 1000, Epoch 5 (epoch_start=1500, midpoint=1550, epoch_end=1600):

Proposal at height 1525: VALID   (1500 <= 1525 < 1550)
Proposal at height 1550: INVALID (>= midpoint)
Attestation at height 1575: VALID (1550 <= 1575 < 1600)
Attestation at height 1600: INVALID (>= epoch_end)
```

### Identity Recreation Prevention

Verifies that time-locked withdrawal provides no advantage for bypassing cooloff—both expire at the same time.

```
cooloff_epochs = 100, decollateralization_delay = 100

Epoch 50: Peer equivocates → cooloff until epoch 150
Epoch 50: Peer initiates withdrawal → claimable at epoch 150
Epochs 50-150: Peer cannot participate (pending collateral, not active)
Epoch 150: Peer can claim, but cooloff also ends → no advantage gained
```

## Security Considerations

### Attack Vectors and Mitigations

| Attack | Description | Mitigation |
|--------|-------------|------------|
| **Pre-computation** | Attacker generates millions of blocks offline, submits whichever wins selection | Freshness proof requires L1 block hash at exactly `epoch_start`—blocks cannot be constructed until the epoch begins |
| **Block swap** | Proposer submits proposal, waits to see if they win, then substitutes different block content | Selection operates on `block_hash`, not proposer identity—changing content changes the hash, changing selection outcome |
| **Sybil** | Attacker creates many identities to dominate proposals/attestations | Collateral requirement makes each identity expensive; attacking requires acquiring `min_collateral` per identity |
| **Identity recreation** | Banned peer withdraws collateral, creates new identity to bypass cooloff | Time-locked withdrawal with delay ≥ cooloff; by the time funds are accessible, cooloff has expired |
| **Equivocation** | Peer submits multiple proposals to increase win probability, or attests to multiple blocks | On-chain detection (group by pubkey, flag duplicates); equivocators enter cooloff period |
| **Reorganization cascade** | L2 reorg changes selection seed, causing cascading reorgs in subsequent epochs | Selection seed is L1 block hash (not previous L2 block)—L2 reorgs don't affect future selections |
| **Block withholding** | Winning proposer publishes on-chain commitment but withholds full block data | Networks may require block submission to multiple peers before publishing proposal; epochs produce null blocks if no valid blocks available |
| **Timing advantage** | Low-latency peers submit proposals at optimal times | Sufficiently long proposal windows reduce timing advantages |
| **Attestation buying** | Losing proposer bribes attesters to vote for their block instead of selection winner | Weighted attestations favor early submissions; by the time a losing proposer knows they lost and organizes bribes, honest attesters have already submitted high-weight attestations |
| **Attester free-riding** | Attesters wait to see which block is accumulating votes before attesting, rather than independently verifying | Weighted attestations reward early submission; honest attesters compute selection winner independently and attest immediately to maximize their weight |
| **Eclipse Attack** | Attacker isolates a node from the network and feeds it false blocks. | Nodes verify block canonicality directly from L1 data—no trust in peers required. |

### Operational Considerations

**Reorganization limits**: Deep reorgs are disruptive. Enforce `max_reorg_depth` and alert operators when approaching limits.

**Collateral illiquidity**: Time-locked withdrawal protects against identity recreation but introduces illiquidity risk. Networks should balance security against operator flexibility when setting delay periods.

**Epoch length tradeoffs**: Shorter epochs provide faster finality but increase L1 transaction frequency. Longer epochs reduce costs but delay finality.

**Block content incentives**: This protocol defines how blocks reach consensus, not what goes in them. Networks SHOULD design reward structures that discourage empty or junk blocks—for example, scaling rewards by valid data size, requiring fee-bearing transactions, or using cryptographically verifiable content like storage proofs. The specific mechanism depends on the application.

**Rewards mechanism**: This CHIP intentionally does not specify how proposers and attesters are rewarded. Reward distribution is implementation-specific—networks may pay per block, scale by attestation weight, distribute from a treasury, or use other mechanisms appropriate to their economics.

### Potential Weaknesses

**Hint spam**: Chia allows anyone to create coins with arbitrary hints. An attacker could spam the hint namespace used by this protocol, forcing peers to filter through many invalid coins when querying proposals, attestations, or collateral. This is a limitation of Chia's hint system, not specific to this protocol.

Even though spam gets filtered (wrong puzzle hash, invalid signature, no collateral), there is overhead in processing it. A well-funded attacker could create millions of coins with valid hints, degrading query performance even though all spam is ultimately rejected.

Implementations SHOULD optimize filtering to minimize this overhead:

1. **Filter by puzzle hash first**: This is the cheapest check. Discard coins with wrong puzzle hash before any cryptographic operations.

2. **Defer signature verification**: BLS signature verification is expensive. Check puzzle hash and collateral existence before verifying signatures.

3. **Cache collateral state**: Maintain an index of collateralized pubkeys per epoch. Skip full collateral queries for pubkeys already verified or already known to lack collateral.

4. **Cache validated results**: Store validated proposals/attestations per epoch. Only process newly-appeared coins on subsequent queries.

5. **Parallel validation**: Filter coins concurrently since each validation is independent.

6. **Track known-bad pubkeys**: Cache pubkeys that have repeatedly failed collateral checks. Deprioritize or skip signature verification for repeat offenders.

The cost of spam (1 mojo + transaction fee per coin) provides almost non-existant economic deterrent, but the collateral requirement means spam from non-collateralized pubkeys is filtered before expensive operations. However, this overhead is a fundamental cost of using L1 as the coordination layer—the protocol trades this cost for the benefit of coordination-free consensus and L1 security. Greater then 1 mojo could be used to combat spam, but it requires peers to hold significant L1 (XCH) funds. Its up to the specific implementation if this is a desirable mitigation tactic.

**Economic viability**: If the economic reward for participating in consensus is less than the L1 transaction costs per epoch, rational peers won't participate. Networks must ensure rewards sufficiently exceed costs, or subsidize participation during bootstrapping.

**L1 dependency**: L2 consensus completely depends on Chia's liveness. If L1 experiences congestion, slow block times, or downtime, L2 epochs stall. There's no fallback mechanism. Chia specifically was chosen because this risk is unlikely, but its worth mentioning. 

**Attestation threshold**: If fewer than `min_attestations` honest peers are online and attesting, epochs cannot finalize. Networks with few participants risk liveness failures during low-activity periods. Null blocks are used as a fallback, but if the network fails meaningful adoption, to many null blocks create a chain with minimal value.

**Capital requirements**: High `min_collateral` values lock up significant capital, potentially limiting participation to wealthy operators. This can be mitigated by using dual-farmed Chia plots for Sybil resistance instead of locked collateral, but that shifts the accessibility equation rather than eliminating it—participation then requires storage infrastructure instead of capital. The right approach depends on the network's goals.

**Gossip dependency**: Attesters must receive full block data via gossip to verify before attesting. If the gossip network is partitioned or slow, honest peers may miss the attestation window even when the winning proposer is honest.

**L1 view synchronization**: Peers must agree on which L1 block is at `epoch_start` to compute the same selection seed. Peers with different views of L1 (due to propagation delays or temporary forks) may disagree on the canonical block.

## Reference Implementation

Conforming implementations MUST:

- Use exact domain separators specified
- Implement hint-based queries for proposals, attestations, and collateral
- Follow deterministic selection with L1-anchored seeds
- Verify all BLS signatures
- Implement time-locked collateral with delay ≥ cooloff
- Handle chain reorganization with lineage verification

## Current Implementation

This protocol is being developed for the **DIG Network**—a decentralized content distribution system on Chia. DIG uses this L2 consensus to coordinate storage proofs, verification attestations, routing information, and content linking across distributed nodes, while keeping L1 transaction costs minimal.

## Glossary

| Term | Definition |
|------|------------|
| **Attestation** | On-chain coin endorsing a specific block |
| **Canonical Block** | Authoritative block for an epoch (most attestations) |
| **Collateral** | Locked XCH proving eligibility |
| **Cooloff** | Ban period after equivocation |
| **Decollateralization** | Two-phase withdrawal: initiate, then claim after delay |
| **Epoch** | Fixed L1 block period producing one L2 block |
| **Equivocation** | Multiple proposals/attestations in one epoch from the same pubkey|
| **Freshness Proof** | L1 block hash proving current-epoch construction |
| **Hint** | Coin metadata enabling O(1) queries |
| **Lineage** | Chain of `prev_block_hash` references |
| **Null Block** | Deterministic empty block inserted when epoch fails to reach `min_attestations` |
| **Proposal** | On-chain coin committing to a block |
| **Reorganization** | Replacing local blocks when canonical chain differs |
| **Selection Seed** | L1 block hash for deterministic winner selection |

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).