CHIP Number   | 0050
:-------------|:----
Title         | Action Layer and Slots
Description   | A singleton inner layer that handles the core needs of complex dApps: efficient multi-action calls in a single spend and persistent state.
Author        | [yakuhito](https://github.com/Yakuhito)
Editor        | [Dan Perry](https://github.com/danieljperry)
Comments-URI  | [CHIPs repo, PR #165](https://github.com/Chia-Network/chips/pull/165)
Status        | Review
Category      | Informational
Sub-Category  | Chialisp
Created       | 2025-07-22
Requires      | -
Replaces      | -
Superseded-By | -

## Abstract
This CHIP proposes a singleton inner layer that handles the common needs of Chia decentralized applications. The combination of puzzles allows singletons to efficiently support more than one ‘action’ (i.e., functionality), much like Solidity contracts have multiple methods that can be called. Moreover, multiple actions can be efficiently called within the same spend, drastically reducing total spend bundle cost. Each action call has access to spend-specific context via the ephemeral state (e.g., am I the first action to run?), as well as long-term context via the persistent/normal dApp state (e.g., what’s the current registration price for an item?). Finalizers are customizable components that can be defined to control the logic the singleton runs at the end of every spend. The default finalizer simply recreates the singleton with a new state, while the reserve finalizer also manages a CAT or XCH reserve owned by the dApp. This proposal also includes slots, another form of persistent storage that leverages the coinset model.

## Motivation
A set of core properties (behavior) can be observed when analyzing most blockchain-powered decentralized applications. Namely:
 * **Multiple capabilities**: A dApp may have multiple distinct functionalities. Users interacting with it may run one or more of these functionalities. For example, a user may add/remove liquidity from a TibetSwap pair or swap one asset for the other.
 * **Multiple interactions from many parties**: As a shared resource, the dApp is expected to support multiple interactions from different parties, sometimes in the same block. A dApp should do this efficiently (i.e., in a way that minimizes transaction cost as much as practically possible), and, ideally, in a way that works well with the mempool’s current Replace-by-Fee rules.
 * **State**: Most dApps have state variables, which are persistent across spends. These variables may be simple values (integers, strings, etc.), lists of values, or even mappings.
 * **Reserves**: Some dApps may also manage user funds. For example, a TibetSwap pair manages the funds of liquidity providers, which it uses to allow traders to swap one asset for the other.

The action layer and slots were designed as a ‘framework’ that takes care of these needs with minimal code changes across apps. This way, Chialisp developers can focus on designing and optimizing an app’s defining logic without having to worry about the aspects described above.


## Backwards Compatibility
This proposal includes a new set of puzzles intended as a dApp framework. The main goal is to greatly simplify dApp development, but their use is completely optional. Both already-deployed and future apps may opt not to use the puzzles described in this CHIP without them being considered as going against the CHIP.

## Rationale
To support multiple actions, a pattern similar to the p2_1_of_n puzzle was employed. Namely, all puzzles allowed to run are put into a Merkle tree whose corresponding root is kept in the action layer. When an action is run, its puzzle, along with the corresponding Merkle proof, are revealed. For subsequent action runs in the same spends, the previous puzzle reveal is referenced, eliminating the need to store and hash the same puzzle reveal multiple times.

Each action is given two states as truths, as well as a user-provided solution. The ephemeral state starts out as `()` for each new singleton spend, giving actions a way to access spend-specific context (e.g., whether the action is the first to be run in the spend, which is relevant if the action uses relative conditions). The second state is persistent - it is preserved across spends and always constitutes the output of the previous action (except for the state given to the first action in the eve singleton spend). Actions return new states to be passed to the next action (or discarded - like the ephemeral state is for the last action run in a spend), as well as a list of output conditions which will be processed and (by default) passed to the singleton layer.

The action layer’s customizable component is called a finalizer, which includes any logic that needs to run at the end of a spend. The default finalizer is a minimal puzzle that only re-creates the singleton coin with a new state. The reserve finalizer also allows the singleton to manage one reserve whose amount is kept in the persistent state (usually as the first value). Actions in singletons leveraging the reserve finalizer can make the reserve output a given condition by prepending a special value (-42) to it.

In some cases, storing values in the persistent state is not appropriate. For example, lists or mappings may grow to have a large number of entries, each of which is only rarely accessed. Storing such data structures in the state would be unoptimal, as the state is passed through all actions that run and hashed every spend. Slots were created to address this problem by offering a more expensive way of storing data that is not needed during most spends. A singleton may create slots - 0-amount coins holding some data - at any time. The special puzzle allows only the owner singleton to later spend the coin to retrieve the data. Slots can also be used to enforce uniqueness of keys across a list of key-value pairs, as described [here](https://blog.fireacademy.io/p/uniqueness-on-chain) and [here](https://blog.fireacademy.io/p/solving-the-problem-of-uniqueness).

## Specification
The action layer can be found [here](https://github.com/Yakuhito/slot-machine/blob/master/puzzles/singleton/action.clsp). The default finalizer can be found [here](https://github.com/Yakuhito/slot-machine/blob/master/puzzles/singleton/finalizer.clsp), and the reserve finalizer can be found [here](https://github.com/Yakuhito/slot-machine/blob/master/puzzles/singleton/reserve_finalizer.clsp). The slot puzzle can be found [here](https://github.com/Yakuhito/slot-machine/blob/master/puzzles/singleton/slot.clsp). More documentation about the action layer and slots can be found [here](https://docs.catalog.cat/technical-manual/action-layer) and [here](https://docs.catalog.cat/technical-manual/slots).


## Test Cases
A series of tests verifying on-chain apps powered by the action layer can be found in chia-wallet-sdk.

## Reference Implementation
The reference implementation can be found [here](https://github.com/Yakuhito/slot-machine). It includes puzzles for three apps that use the action layer: CATalog, XCHandles, and the Reward Distributor. Apps are in varying states of completion and will have their own subsequent CHIPs. A CLI tool for viewing and interacting with the apps through Coinset.org and the Sage RPC is also included in the repository.

Drivers for the action layer and associated apps, as well as tests, have been integrated into chia-wallet-sdk.


## Security
Puzzle security risk is the main concern when it comes to this standard. Multiple members of the Chia community have reviewed the standardized components of the action layer (‘action.clsp’, the default and reserve finalizers, and the slot puzzle). Chialisp developers implementing actions or custom finalizers should perform full audits on new apps, as the action layer is not intended to act as a security sandbox.

## Copyright
Copyright and rights to this CHIP waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
