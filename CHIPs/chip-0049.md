CHIP Number  | 0049
:------------|:----
Title        | 3.0 Fork Info
Description  | Provide all info that will be included in the 3.0 fork
Author       | [Arvid Norberg](https://github.com/arvidn)
Editor       | [Dan Perry](https://github.com/danieljperry)
Comments-URI | [CHIPs repo, PR #161](https://github.com/Chia-Network/chips/pull/161)
Status       | Draft
Category     | Standards Track
Sub-Category | Core
Created      | 2025-05-19
Requires     | [0048](https://github.com/Chia-Network/chips/pull/160)

## Abstract
[CHIP-48](https://github.com/Chia-Network/chips/pull/160), which introduces the new Proof of Space format (PoS v2), requires a hard fork of the Chia blockchain. This document describes how PoS v2 will be integrated with the blockchain, as well as how original plots will be phased out. This CHIP also proposes a few other hard-fork changes, unrelated to the new proof format.

## Motivation
The current Proof of Space format (PoS v1) was released in July 2020, during the Chia blockchain’s beta phase. Five years later, the format remains secure. However, two broad issues exist, one of which remains hypothetical, and the other of which is in production today.

The hypothetical issue is plot grinding. This is where a farmer creates an entire plot and submits a proof within around 28 seconds. Plot grinding is described in detail in [CHIP-12](https://github.com/Chia-Network/chips/blob/main/CHIPs/chip-0012.md).

The other issue is plot "compression," where bits are dropped during a plot's creation, and added back in while farming. The result is a farm that squeezes more proofs into the same space. Plot compression is described in detail in a [blog post](https://www.chia.net/2023/01/21/plot-compression-is-here/).

Neither of these issues is an attack on the network itself, but in both cases, they make time-space tradeoffs, which cause the plots’ Proof of Space to begin to resemble Proof of Work (PoW). As a consequence, the network uses more compute than what was originally intended.

In the first half of 2024, we made the decision to sunset the existing proof format in favor of a new one that will be significantly more resilient to bit dropping and other time-space tradeoffs. Farmers will need to replace their existing plots with new ones, so we have built this format with minimizing future disruptions in mind.

We will future-proof the new format with two independent mechanisms:
1. Automatically reducing the network's base filter (can be delayed with a soft fork)
2. Manually increasing the network's minimum plot strength (a soft fork)

Both of these adjustments are detailed in the [Specification](#specification) section.

## Backwards Compatibility
This CHIP proposes a hard fork to upgrade the proof format. Hard forks relax rules. Blocks that are invalid by the existing rules will be considered valid by the new rules (and sometimes vice versa). This is why every node must update for a hard fork to be accepted. If this CHIP is accepted, then there will be a window of several months prior to its activation for all full nodes, farmers, and harvesters to be upgraded.

Even though the original plot format will be disabled by this CHIP, it will remain valid until the end of a phase-out period, which starts at hard fork activation.

## Specification
The specification for each of this CHIP’s features will be listed individually.

### Fork activation
We will release Chia version 3.0.0, which will implement the hard fork. The fork will activate in the block immediately following the first *transaction* block, with a later signage point, at or above height [todo]. This is expected to happen around [todo].
A signage point may have multiple blocks. If the block immediately following the transaction block at the activation height happens to be on the same signage point, it will also be pre-activation. The hard fork activates with the next signage point.

Starting with the block in which the hard fork is activated, the new Proof of Space will be accepted.

This hard fork is different from previous forks in that it affects the validity of Proofs of Space. When farming a block, the harvester does not know (exactly) at what height its proof may be infused. However, it *can* know what the most recent transaction block was.

### Phase-out period
During the phase-out period, original Proofs of Space will become increasingly unlikely to win a block. The probability of winning a block will be scaled down, linearly, starting at the activation block, to reach 0 probability after 256 days (technically, 4608 x 256 blocks).

In order for a plot to win a block, it first needs to pass the plot filter. The proof’s quality then needs to yield a low enough required iterations, lower than the signage point interval iterations. The required iterations count is part of the block’s infusion iterations calculation:

```infusion_iterations = (signage_point_iterations + 3 * signage_point_interval_iterations + required_iterations) % sub-slot_iterations```

A higher required iteration count means the proof is less likely to be valid.

The phase-out counter (`i`) starts at 0 at the hard fork activation. Every 4608 blocks, it’s incremented by 1. When computing `required_iterations` for original Proofs of Space, we add `signage_point_interval_iterations * (i // 256)` to required iterations, so the calculation becomes:

```infusion_iterations = (signage_point_iterations + 3 * signage_point_interval_iterations * (i // 256) + required_iterations) % sub-slot_iterations```

[todo] (i // 256) might be wrong

Just like the hard fork activation, each increment of `i` happens immediately following the first transaction block whose height is [todo (activation height)] + i * 4608 or above.

Once `i` reaches 256, we end up adding `signage_point_interval_iterations` (or more) to the required iterations, so no original proof will ever be valid. This ends the phase-out period and effectively disables the original Proof of Space.

[todo update heights ni this table]

| Blocks w/prev. TX block >= | i   | Win prob. factor |
|:-------------------------- | :-- | :--------------- |
| 8800000                    | 0   | 1.000            |
| 8804608                    | 1   | 0.996            |
| 8809216                    | 2   | 0.992            |
| 8813824                    | 3   | 0.988            |
| …                          | …   | …                |
| 9970432                    | 254 | 0.008            |
| 9975040                    | 255 | 0.004            |
| 9979648                    | 256 | 0.000            |

### Protocol
A `FullNode` object contains a `ProofOfSpace` which has these fields:
```
size: u8,
proof: Bytes,
```
The `size` is not allowed to be less than 32 or greater than 50. After the hard fork, the most significant bit in the `size` field indicates whether the proof is the original Proof of Space (0) or the new Proof of Space (1). 

The remaining 7 bits then indicate either:
* The k-size of the plot that produced the proof (original Proof of Space), or
* The strength of the plot that produced the proof (new Proof of Space)

The only valid k-size in the new Proof of Space is 28 (mainnet/testnet) and 18 (testnet only).
The `proof`s are either v1 or v2 Proof of Space, depending on the most significant bit in the `size` field.

### Filter and strength adjustments
We have two ways to future-proof the network against rental attacks, and plot grinding more generally: automatic reductions in the base filter, and manual increases in the network's minimum plot strength. Both of these will be detailed in this section.

At every signage point, a certain number of plots are excluded from participating in the challenge. In the original Proof of Space protocol, this was known as the `plot filter`, and is described in [our documentation](https://docs.chia.net/chia-blockchain/consensus/chains/signage-and-infusion-points/). In Proof of Space v2, there are now two related filters to consider: the network's base filter, and an individual plot's ID filter.

#### Base filter definition and plan
The base filter indicates the lowest filter allowed for all plots across the network. This filter will start `1024` and will automatically be adjusted downward every two years at pre-defined block heights, until it reaches `64`. It will remain at `64` thereafter.

The reason to reduce the base filter over time is to decrease the leverage a rental attacker is able to gain. This topic is covered extensively in [CHIP-12](https://github.com/Chia-Network/chips/blob/main/CHIPs/chip-0012.md). In summary, a rental attacker can opt to exclusively create plots that will pass the filter, so the amount of space they are able to spoof is multiplied by a given plot's ID filter ([described below](#plot-id-filter-definition)). As GPUs become faster, we can initially protect the network against rental attacks by proactively reducing the Plot ID filter. However, for technical reasons covered in CHIP-48, we won't reduce the filter to be lower than `64`. The next protection against rental attacks will come from increasing the minimum plot strength, which will be [covered later](#minimum-strength-plan).

Cutting the base filter in half every two years will have two impacts for all farmers: higher disk usage, and longer plot stability.

##### Disk usage
Each time the base filter is cut in half, the likelihood that a plot will pass it is doubled. The load on individual disks will therefore roughly double as well.

HDDs can operate at 20% of capacity without significantly shortening their life expectancy. The filter will be cut in half four times over the course of eight years, so if a farmer expects their disks to last for eight years, then they should plot so that their disks initially run at 1% of capacity or lower. That way, their disks will never run at more than 16% of capacity, so they will remain viable for farming for their entire life expectancy.

Read speeds of SSDs are much faster than those of HDDs, so farmers can safely plot their SSDs at the minimum strength without running into issues related to high disk usage. However, they should still plan according to the expected scheduling for minimum strength increases, which are [covered later](#minimum-strength-plan).

##### Plot stability
By decreasing the base filter every two years for the first eight years of the new Proof of Space's existence, we expect to be able to keep the minimum strength at `0` for that time frame. This means that all plots created at the minimum strength are expected to be valid for at least eight years, pending unexpected advancements in technology.

Starting around 2034, plot stability will come entirely from plotting to a higher strength than the minimum.

#### Plot ID filter definition
Each plot will have its own `plot ID filter`, which determines the likelihood that it is eligible to participate in a challenge at a given signage point. The plot ID filter is calculated based on a given plot's strength. [CHIP-48](https://github.com/Chia-Network/chips/pull/160) provides the technical details. 

The formula to calculate a given plot's ID filter is:
`plot ID filter = base filter * (2^(plot strength - min strength))`

For each level that a given plot's strength is higher than the network's base strength, the plot ID filter will be doubled.

#### Plot strength definition
As detailed in CHIP-48, every plot will include a “strength” parameter, which will adjust how much time is required to create the plot, _ceteris paribus_. If a given plot's strength is `n`, then creating the plot will require `2^n` times longer than the minimum amount of time. (Harvesting time is unaffected by the plot’s strength.) At a given block height, the network will only accept plots that meet the current minimum strength threshold.

By definition, `strength = 0` indicates the minimum compute required to create a plot, with no additional arbitrary computation.

The maximum allowed strength will be [TODO]. This strength is capped arbitrarily, in order to prevent future attacks which may emerge from applying an extremely high strength to one or more plots.

#### Minimum strength plan
The network's minimum strength will start at `0`, and will be adjusted upward as needed. Adjusting the minimum strength will require a soft fork. We won't plan to increase the minimum strength for the first eight years after the PoS2 fork activates, barring any unexpected advancements in technology.

The minimum strength should only ever be increased with time. It can be increased by any integer, but typically we will only increase it by 1 in a given soft fork. Because any plots with the current minimum strength will need to be recreated when the minimum strength is increased, we plan provide a lengthy warning (perhaps six or twelve months) for a fork that increases the minimum strength to activate.

In order to decrease the number of expected replots, some farmers might initially choose to plot to a high strength. In order to keep up with advancements in technology, we might need to increase the minimum strength every two years (though keep in mind that this is a rough estimate).

One thing to note is that a given farm can contain plots with various strength levels. Some farmers may choose a strategy of plotting their entire farm at the minimum current strength, and then gradually replacing their plots with higher-strength plots over time. A plot's size is unaffected by its strength.

#### Expected base filter and strength
To recap:

The base filter will start at `1024` and will be cut in half every two years until it reaches `64`. These adjustments will happen automatically, and can be delayed with a soft fork.

The minimum strength will start at `0` and will be increased via a soft fork as needed. We won't plan to increase the minimum strength until at least 2036, though this is subject to change.

The following table illustrates how we expect these adjustments to occur. The second column from the right shows the plot ID filter for a plot created at `strength = 3`, and the rightmost column shows how often that plot will pass the filter, on average. This plot will take eight times longer than the minimum to be created, and is expected to be valid into the 2040s. It will only become invalid when the minimum strength reaches `4`.

| Block height | Month/Year (app.) | Base Filter | Min Str | Filter at Str=3 | Pass Frequency |
| :----------- | :---------------- | :---------- | :------ | :-------------- | :------------- |
| TODO         | July 2026         | 1024        | 0       | 8192            | 1 day          |
| TODO         | July 2028         | 512         | 0       | 4096            | 12 hours       |
| TODO         | July 2030         | 256         | 0       | 2048            | 6 hours        |
| TODO         | July 2032         | 128         | 0       | 1024            | 3 hours        |
| TODO         | July 2034         | 64          | 0       | 512             | 80 minutes     |
| TBD          | TBD               | 64          | 1       | 256             | 40 minutes     |
| TBD          | TBD               | 64          | 2       | 128             | 20 minutes     |
| TBD          | TBD               | 64          | 3       | 64              | 10 minutes     |
| TBD          | TBD               | 64          | 4       | Invalid         | N/A            |

### Plot groupings
In PoS v2, farmers are recommended to combine multiple plots into a single _group_. This will work by combining multiple plots together, as if they were the same plot.

The length of a plot ID 256 bits (32 bytes). The first 240 bits are define the plot itself, and the final 16 bits represent that plot's slot in the group. Plots that are part of the same group will have IDs that begin with the same 240 bits. For example, if two plots are to be grouped together, their IDs might look like this (shown in base-16):

1. [todo]0
2. [todo]1

[todo] Add naming convention here, will it include k-size and creation date? Also, will it actually be 512 bit (64 hex chars)?
[todo] describe how memory is used and managed when combining plots, how much extra memory and compute are needed?

Because the final 16 bits are used to determine the slot in the group for each plot, the maximum number of plots that can be included in a group is 2**16 (65,536), or about 65 TB.

Grouping multiple plots together is required beyond a few thousand plots on HDDs, and is recommended on SSDs as well. If plots are not grouped together, then multiple lookups will be needed at each signage point.

For example, a 20-TB HDD will hold around 20,000 plots. If the plot ID filter for these plots is 256, and the plots are not grouped, then an average of around 78 plots will pass each the filter at each signage point. This will require a large amount of lookups, which could affect the harvester's ability to respond on time.

However, grouping _too many_ plots together could also cause issues, though they would be minor in comparison. Due to the extra memory required to group plots together, creating a group with more than 128 plots is not generally recommended. In addition, because a plot group acts as a single plot, larger groups will also increase the volatility of block rewards being won. This volatility is only noticeable in the short term, though -- the long-term expected win rate will be unaffected by large group sizes.

Keeping the above considerations in mind, the recommended group size is 128. This will yield plot groups of around 120 GB, which is roughly the same size as v1 plots. For plotters with lower RAM, grouping 64 plots together is also fine.

However, there are exceptions to these recommendations For example, older HDDs with low capacities may not be profitable for some farmers due to ongoing electricity costs. However, these HDDs could be filled with plots that are grouped together so that the entire HDD consists of a single "plot". These HDDs could then be powered down until their plot is about to pass the filter, which would save on electricity. This is [described in detail](#powering-down-hdds) below.

### Meta groupings
All plots in a standard plot group will pass the plot ID filter together. However, the plot groups themselves will occasionally also pass the filter together. By using _meta groupings_, one can guarantee that separate groups will never pass the filter together. This can be beneficial, for example, in order to reduce the chances that a disk becomes overloaded from excessive lookups. It also will somewhat help to smooth out rewards.

[todo] other advantages?
[todo] are we still doing meta groupings?

### Plot ID filter calculation
The formula to determine whether a given plot passes the plot ID filter will be modified for the new Proof of Space protocol. In this section, we'll start by describing this formula for PoS v1, along with its deficiencies. Next, we'll describe the new formula for PoS v2, along with its advantages.

#### Old formula and deficiencies
In the original Proof of Space protocol, plots randomly pass (or don't pass) the filter at each signage point. This is determined by hashing the plot ID concatenated with the current challenge and signage point:

`plot filter bits = sha256(plot ID + sub slot challenge + challenge chain signage point)`

If `plot filter bits` begins with a certain number of zeroes, then the plot passes the filter. For example, if the plot filter is `256`, at each signage point, a plot will have will have a 1 in 256 chance of passing the filter (`plot filter bits` must begin with eight zeroes in this case). Because `plot filter bits` is calculated from a `sha256` hash, the plot has an equal chance of passing the filter at any given signage point.

There is also no mechanism to prevent the plot from passing the filter at multiple consecutive signage points. By analogy, if I roll a die three times, the result might be `1` each time. This means that a plot will have a 1 in 65,536 (256 * 256) chance of passing two consecutive signage points, and a 1 in 16,777,216 (256 * 256 * 256) chance of passing three consecutive signage points.

Plot grinders can generate a plot ID without creating the plot, so they can grind through millions of plot IDs per second. This means that at any given signage point, they can grind a plot ID that will pass it, as well as the next two signage points, giving them extra leverage. The details of plot grinding, and the leverage gained, are shown in [CHIP-13](https://github.com/Chia-Network/chips/blob/dad0822f4142bb0da70f31cb2d15aba366d64532/CHIPs/chip-0013.md).

#### New formula
[todo] update this formula; currently it's for up to 10 minutes of lead time, but we'll change it to 40-120 seconds

In order to prevent the extra grinding leverage described above, the Proof of Space v2 protocol will change the formula to determine whether a plot passes the filter. We'll start with some definitions:
* `challenge_value` -- the challenge from the beginning of a subslot. It should kick in several signage points after being calculated and last for one subslot (64 signage points)
* `challenge_height` -- the subslot's offset within the range it applies (must be an integer from `0` to `63`)
* `filter_bits` -- the strength of the plot group
* `plot_group_id` -- the hash of everything which defines the group
* `meta_group` -- used to make sure the load from different plot groups is spread out (must be an integer from `0` to `2**filter_bits`)

These values apply the same to all specific plots within the group. Their only difference is an index.

The following function uses the above values to determine whether a plot passes the filter at a given signage point:
```python
def passes_plot_id_filter(challenge_value, challenge_height, filter_bits, plot_group_id, meta_group):
    mask = (1 << filter_bits) - 1
    multiplier = ((challenge_value >> filter_bits) | 1) & mask
    current_value = ((challenge_value << 6) & mask) | challenge_height
    return current_value == (plot_group_id ^ ((meta_group * multiplier) & 63)) & mask
```

The main two advantages of using this new formula is that it removes the potential extra leverage from plot grinding, and that it makes it possible to power down HDDs between times when they pass the filter. Both of these advantages are detailed below.

#### No extra leverage when grinding
By using the new formula, we can guarantee that a plot group won't pass the plot ID filter more than once every four signage points. This means that the extra leverage the could previously be gained from grinding a plot's ID is no longer applicable. Plot grinders will be able to create plots on the fly, but it won't be possible to have a multiplier effect. The new formula will therefore accomplish the original goal of the defunct [CHIP-13](https://github.com/Chia-Network/chips/blob/dad0822f4142bb0da70f31cb2d15aba366d64532/CHIPs/chip-0013.md).

#### Powering down HDDs
In addition, it will now be possible to predict between 4 to 20 signage points (~37 seconds to two minutes) in advance when a plot group will pass the filter. This will make it possible to power down a hard drive, and start it up in advance of the plot group passing the filter. A few guidelines should be followed in order to maximize the efficiency of this use case.

##### Group many plots together
If a farmer's goal is to maximize the timing between wake-ups (as opposed to smoothing rewards), an HDD should ideally be filled with a single plot group. If a 20-TB HDD were filled with 4 plot groups of 5 TB, and the filter for those plots were 8192, then the HDD would need to be started and stopped four times daily, on average. But if the same HDD were filled with a single plot group of 20 TB and the same filter, then it would only need to be started and stopped once daily.

##### Use smaller HDDs
HDDs use a similar amount of electricity, regardless of their capacity. In PoS v1, this made small HDDs economically unprofitable. In PoS v2, powering down these smaller disks will potentially make them profitable. However, the advantage of powering down an HDD is reduced as the HDD's capacity is increased. It may turn out that there is little advantage to powering down a modern, large-capacity HDD. It may actually be a disadvantage due to the increased compute needed to create a plot group for the large HDD, as well as due to the extra wear caused by repeatedly shutting down and starting up an HDD.

##### Plot to a high strength
Per the above table, plot groups that were created at strength `3` will initially pass the filter once per day. After two years, this frequency will be reduced to 12 hours, and after four years, it will be reduced to 6 hours. Farmers may not be comfortable with starting and stopping their HDDs more than four times daily, so in order to take advantage of this use case for six years, they will need to plot to at least strength `3`, which requires 8x the compute of strength `0`.

#### Determining when a plot group will pass
[todo] describe how to figure this out so that you have plenty of time to start your HDD
For example, if my plot will pass the filter at signage point 0, is this going to be determined from the previous subslot's challenge?
[answer] The ideas is that every 16th challenge point is used for the plot id filter and it applies to the challenge points 4-20 ahead of it

### keccak256
The `keccak256` operator was previously added via soft fork, and is therefore only available under the `softfork` operator. Its usage (both inside and outside the `softfork` guard) is described in [the Specification section of CHIP-36](https://github.com/Chia-Network/chips/blob/main/CHIPs/chip-0036.md#specification).

The hard fork gives us the opportunity to promote `keccak256` to be allowed outside the `softfork` guard. This makes it easier to use.

After block 8,800,000, the `keccak256` operator will become part of the core CLVM, so it will be usable by calling it directly. It will also continue to be usable from inside the `softfork` guard.

### sha256tree
Many puzzles use the [sha256tree](https://github.com/Chia-Network/chia_puzzles/blob/0b46a6ebfc3b432d68edf9b91e6cef0ec13da2e7/puzzles/sha256tree.clib) library, which calculates the puzzle hash of a given puzzle program. This library is used so frequently, in fact, that it makes sense to include it as a native CLVM operator in the hard fork. Another advantage of including `sha256tree` in the CLVM is that it will be cheaper to call, both in terms of CPU compute and CLVM cost.

#### Technical info about sha256tree
Opcode: 63

Argument: Exactly one valid CLVM tree

Returns: The `sha256` puzzle hash (Merkle root) of the input tree

Usage: (sha256tree (TREE))

CLVM Cost: [todo]

### Conditions with cost
Currently, only `CREATE_COIN`, the `AGG_SIG_*`-family and `SOFTFORK` conditions have a cost. All other conditions are free and could therefore risk being a DoS vector. The full node currently limits the number of announce-family conditions per coin spend to 1024 (See [CHIP-25](https://github.com/Chia-Network/chips/blob/main/CHIPs/chip-0025.md#clvm-cost)). Conditions in this family are expensive because they require memory allocation during validation.

With [Vaults](https://www.chia.net/2025/01/31/chia-vaults-a-secure-and-flexible-way-to-manage-your-digital-assets/), each coin spend requires a message to be sent from the vault to the coin. This makes the 1024 limit at risk of being hit by legitimate uses.

After the hard fork activates, the limit of 1024 announcement conditions per spend will be removed.

Instead, for each CoinSpend, conditions will have a cost of 500, **except** for the first 100 conditions, which will not incur an additional cost. This is in addition to any existing cost for the condition. This cost applies to all conditions, including unknown conditions, `SOFTFORK`, `CREATE_COIN` and `AGG_SIG_*` conditions.

### New Weight Proof Commitments
The 3.0 fork will include [new weight proof commitments](https://github.com/Chia-Network/chia-blockchain/pull/20340) that use Merkle Mountain Ranges for easier and faster validation. These include commitments to block headers, as well as to transaction blocks. The main things to be included are:
* Linking the trunk to the Merkle root of foliage blocks across epochs
* Adding to a Merkle Mountain Range of transaction blocks within sub-epochs
* Adding commitments to the root of subslots, including the number of blocks per branch for epochs

Before the new weight proofs can be used, there will need to be a transition point between the old and new proofs. This will necessitate that both formats work simultaneously for some time. The current proposal is to put in a checkpoint some time after the 3.0 fork activates, and wait enough time before we use the new weight proof so that everyone agrees on the past before the checkpoint. 

After we can begin validating the new weight proofs (9-12 months after 3.0 is released), nodes and wallets won’t be required to sync. Their peers only will need to prove the peak height and its weight in order for their data to be proven trustworthy. The current requirement for block validation will instead become a recommendation.

### New Block Hash Computation
In order to calculate block hashes, currently we hash the serialization blob of the block generator (a CLVM object).

The 3.0 release will include an update to hash the generator as a sha256tree (just as we do with puzzle hashes), and then the particular serialization won’t matter. This will open the door to arbitrary compression mechanisms without forking.

Beginning in block [todo], the new block hash computation will be accepted. The old method will continue to be accepted until block [todo], after which it will be ignored.

The original CLVM cost of calculating the generator was `12'000 * len(blob)`. The new cost is `len(blob)`.

## Test Cases
All relevant test cases are included in CHIP-48.

## Reference Implementation
The reference implementation is included in CHIP-48.

## Security
The majority of the security work for the new proof format can be found in CHIP-48. That said, CNI has also performed an internal audit of the code updates involved with this CHIP.

## Additional Assets
None

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
